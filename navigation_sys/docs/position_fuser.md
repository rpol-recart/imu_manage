# **Техническая документация: Модуль `/processing/position_fuser.py`**

---

## **1. Общее описание**

Модуль `position_fuser.py` предназначен для **фузии данных от GPS и IMU (Inertial Measurement Unit)** с целью получения **точной позиции (широта, долгота, высота), ориентации (азимут)** и **оценки достоверности (confidence)** местоположения техники в заданный момент времени.

Модуль реализует **гибкую, масштабируемую и тестируемую архитектуру**, основанную на принципах **SOLID**, **Dependency Injection**, и **протоколов типов (Protocol)**, что обеспечивает:

- Расширяемость (например, добавление новых стратегий обработки датчиков).
- Легкость тестирования (возможность мокирования компонентов).
- Четкое разделение ответственностей (Single Responsibility).

---

## **2. Назначение модуля**

Основная цель — **объединение данных с нескольких источников (GPS, IMU)** в единую оценку положения и ориентации техники, с учетом временной синхронизации, интерполяции и выбора оптимального источника азимута (GPS или IMU).

Используется в системах **мониторинга и управления техникой**, где требуется высокая точность позиционирования.

---

## **3. Архитектура и компоненты**

Модуль состоит из нескольких **взаимодействующих классов**, каждый из которых отвечает за свою часть процесса:

| Класс | Назначение |
|------|-----------|
| `PositionFuser` | Главный класс, координирует процесс фузии. |
| `SensorDataAggregator` | Агрегирует данные GPS по `sensor_id`. |
| `SingleSensorProcessor` | Обработка случая с одним GPS-датчиком. |
| `DualSensorProcessor` | Обработка случая с двумя GPS-датчиками (заглушка). |
| `GeodeticAzimuthCalculator` | Вычисляет азимут по двум GPS-точкам с использованием геодезических формул. |
| `FusionResult` | Результат фузии в виде структурированного объекта. |

---

## **4. Интерфейсы и типы данных**

### **4.1. Перечисления (Enum)**

#### `AzimuthSource`
Источник данных для азимута.

| Значение | Описание |
|--------|--------|
| `GPS` | Азимут рассчитан по двум GPS-точкам (движение) |
| `IMU` | Азимут взят из данных инерциального датчика |
| `NONE` | Азимут недоступен |

#### `FusionStatus`
Статус результата фузии.

| Значение | Описание |
|--------|--------|
| `SUCCESS` | Успешная фузия |
| `UNKNOWN` | Статус не определён (например, заглушка) |
| `FUSION_ERROR` | Ошибка в процессе фузии |
| `INSUFFICIENT_DATA` | Недостаточно данных для обработки |

---

### **4.2. Dataclass**

#### `GpsPoint`
Представляет точку GPS.

| Поле | Тип | Описание |
|------|-----|--------|
| `timestamp` | `int` | Временная метка (Unix time в мс) |
| `lat` | `float` | Широта (в градусах) |
| `lon` | `float` | Долгота (в градусах) |
| `alt` | `float` | Высота над уровнем моря (в метрах) |

#### `SensorRecord`
Запись с датчика.

| Поле | Тип | Описание |
|------|-----|--------|
| `sensor_id` | `str` | Идентификатор датчика (например, "gps_front") |
| `timestamp` | `int` | Временная метка (Unix time в мс) |
| `data` | `Dict[str, Any]` | Полезные данные (например, `{"lat": 55.75, "lon": 37.62, "alt": 150}`) |

#### `FusionResult`
Результат фузии.

| Поле | Тип | Описание |
|------|-----|--------|
| `lat` | `Optional[float]` | Широта (или `None`, если недоступна) |
| `lon` | `Optional[float]` | Долгота |
| `alt` | `Optional[float]` | Высота |
| `azimuth` | `Optional[float]` | Азимут в градусах (0–360) |
| `timestamp` | `int` | Целевое время оценки |
| `confidence` | `float` | Уровень достоверности (0.0–1.0; в этом модуле пока не рассчитывается) |
| `status` | `FusionStatus` | Статус процесса |
| `source` | `AzimuthSource` | Источник азимута |

Метод:
- `to_dict()` — преобразует объект в словарь для передачи в API.

---

### **4.3. Протоколы (Protocol)**

#### `AzimuthCalculator`
Протокол для вычисления азимута между двумя GPS-точками.

```python
def calculate_azimuth(self, point1: GpsPoint, point2: GpsPoint) -> float
```

Позволяет подменять реализацию (например, для тестов или альтернативных методов).

---

## **5. Ключевые классы**

### **5.1. `GeodeticAzimuthCalculator`**

Реализует `AzimuthCalculator` с использованием библиотеки `geographiclib`.

- Использует **геодезические вычисления (WGS84)** для точного расчета азимута.
- Учитывает кривизну Земли.
- Результат округляется до 2 знаков после запятой.

> **Важно**: Азимут — это угол от севера по часовой стрелке (в градусах).

---

### **5.2. `SensorDataAggregator`**

Агрегирует GPS-записи по `sensor_id`.

- **Вход**: список `SensorRecord` с GPS-данными.
- **Выход**:
  - `Dict[str, List[Tuple[int, Dict]]]` — данные по датчикам.
  - `Dict[str, List[int]]` — временные метки.

Пример:
```python
{
    "gps_front": [(1700000000000, {"lat": 55.75, "lon": 37.62}), ...],
    "gps_rear": [(1700000000000, {"lat": 55.74, "lon": 37.63}), ...]
}
```

---

### **5.3. `SingleSensorProcessor`**

Обрабатывает случай **одного GPS-датчика**.

#### Логика:
1. Берет **две последние точки** GPS (по времени).
2. Вычисляет азимут:
   - Если есть IMU → использует IMU (заглушка).
   - Иначе → вычисляет по GPS (через `GeodeticAzimuthCalculator`).
3. Возвращает позицию последней точки.

> **Пока IMU не реализовано** — возвращает `None` для азимута.

#### Обработка ошибок:
- Недостаточно данных → `INSUFFICIENT_DATA`
- Ошибка → `FUSION_ERROR`

---

### **5.4. `DualSensorProcessor`**

Обрабатывает случай **двух GPS-датчиков** (например, спереди и сзади).

#### Текущее состояние:
- **Заглушка** — возвращает `UNKNOWN`.
- Проверяет свежесть данных (максимальные временные метки).

#### Будущее расширение:
- Вычисление азимута по разнице координат двух датчиков.
- Повышенная точность ориентации.

---

### **5.5. `PositionFuser` (Основной класс)**

#### Инициализация:
```python
PositionFuser(
    azimuth_calculator: Optional[AzimuthCalculator] = None,
    logger: Optional[logging.Logger] = None
)
```

- По умолчанию: `GeodeticAzimuthCalculator`, логгер из `LoggerService`.

#### Метод: `fuse_position_data(...)`

**Вход:**
```python
{
    'gps': [
        {'sensor_id': 'gps_front', 'timestamp': 1700000000000, 'data_json': {'lat': 55.75, 'lon': 37.62, 'alt': 150}},
        ...
    ],
    'imu_orientation_data': [
        {'sensor_id': 'imu_1', 'timestamp': 1700000000000, 'data_json': {'yaw': 45.0}},
        ...
    ]
}
```

**Выход:**
```python
{
    "lat": 55.75,
    "lon": 37.62,
    "alt": 150,
    "azimuth": 45.0,
    "timestamp": 1700000000000,
    "confidence": 0.0,
    "status": "success",
    "source": "imu"
}
```

#### Этапы работы:
1. Парсинг входных данных → `SensorRecord`.
2. Агрегация GPS по `sensor_id`.
3. Выбор стратегии:
   - 1 датчик → `SingleSensorProcessor`
   - 2 датчика → `DualSensorProcessor`
   - иначе → ошибка
4. Возврат результата в формате `dict`.

---

## **6. Вспомогательные функции**

### `get_azimuth_by_points(last_point, prev_point) → float`

- **Назначение**: обратная совместимость с устаревшим кодом.
- **Формат входа**: словари с `lat`, `lon`.
- **Возвращает**: азимут в градусах.
- **Рекомендация**: использовать `GeodeticAzimuthCalculator` напрямую.

---

## **7. Обработка ошибок и статусов**

| Ситуация | Статус | Источник азимута |
|--------|--------|----------------|
| Нет GPS | `INSUFFICIENT_DATA` | `NONE` |
| Менее 2 точек GPS | `INSUFFICIENT_DATA` | `NONE` |
| Ошибка в обработке | `FUSION_ERROR` | `NONE` |
| Один GPS, есть IMU | `SUCCESS` | `IMU` (если реализовано) |
| Один GPS, нет IMU | `SUCCESS` | `GPS` |

---

## **8. Ограничения и TODO**

### **Текущие ограничения:**
- IMU-обработка **не реализована** (`_extract_imu_azimuth` возвращает `None`).
- Обработка двух GPS-датчиков — **заглушка**.
- `confidence` всегда `0.0` (должен рассчитываться в другом модуле).
- Нет интерполяции GPS/IMU по времени (должна быть реализована в `interpolation.py`).

### **План доработки:**
1. Реализовать извлечение азимута из IMU (через `interpolate_orientation_data`).
2. Реализовать обработку двух GPS-датчиков (вычисление азимута по вектору между ними).
3. Добавить интерполяцию GPS-точек по времени.
4. Добавить оценку confidence (на основе дисперсии, частоты обновления и т.д.).

---

## **9. Пример использования**

```python
from processing.position_fuser import PositionFuser

fuser = PositionFuser()

sensor_data = {
    'gps': [
        {
            'sensor_id': 'gps_main',
            'timestamp': 1700000000000,
            'data_json': {'lat': 55.7558, 'lon': 37.6176, 'alt': 147.0}
        },
        {
            'sensor_id': 'gps_main',
            'timestamp': 1699999999000,
            'data_json': {'lat': 55.7557, 'lon': 37.6175, 'alt': 147.0}
        }
    ],
    'imu_orientation_data': []
}

result = fuser.fuse_position_data(sensor_data, target_timestamp=1700000000000)
print(result)
# {'lat': 55.7558, 'lon': 37.6176, 'alt': 147.0, 'azimuth': 45.2, ...}
```

---

## **10. Зависимости**

| Библиотека | Назначение |
|-----------|-----------|
| `geographiclib` | Геодезические вычисления (азимут) |
| `geopy` | Расчет расстояний (используется в `geometry`, но не напрямую в этом модуле) |
| `dataclasses` | Структурирование данных |
| `typing` | Аннотации типов |
| `logging` | Логирование |

---

## **11. Логирование**

Используется `LoggerService` (внешний сервис логирования).  
Ключевые события:

- `info`: инициализация, отсутствие данных.
- `debug`: агрегация, временные метки.
- `warning`: недостаточно данных, неподдерживаемое количество датчиков.
- `error`: исключения при обработке.

---

## **12. Принципы проектирования**

- **SOLID**:
  - **Single Responsibility**: каждый класс отвечает за одну задачу.
  - **Open/Closed**: легко добавить новые стратегии (например, `MultiSensorProcessor`).
  - **Liskov Substitution**: `AzimuthCalculator` можно заменить моком.
  - **Interface Segregation**: используется `Protocol`.
  - **Dependency Inversion**: зависимости внедряются через конструктор.
- **Dependency Injection**: для тестирования и гибкости.
- **Type Hints**: повышение читаемости и безопасности.

---

## **13. Рекомендации по использованию**

- Используйте `PositionFuser` как основной интерфейс.
- Для тестов подменяйте `azimuth_calculator` на мок.
- Не полагайтесь на `confidence` — он не рассчитывается в этом модуле.
- Для IMU и интерполяции используйте вспомогательные модули (`interpolation.py`, `orientation.py`).



✅ **Готово к использованию в production (с учетом ограничений)**  
🔧 **Требует доработки IMU и DualSensorProcessor для полной функциональности**